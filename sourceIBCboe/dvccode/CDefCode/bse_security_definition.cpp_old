#include "dvccode/CDef/bse_security_definition.hpp"
#include "dvccode/CDef/common_security_definition_structs.hpp"
#include "dvccode/CDef/currency_convertor.hpp"
#include "dvccode/CDef/file_utils.hpp"
#include "dvccode/CommonDataStructures/perishable_string_tokenizer.hpp"
#include "dvccode/CommonTradeUtils/date_time.hpp"
#include "dvccode/Utils/bse_utils.hpp"
#include "dvccode/Utils/holiday_manager.hpp"

#include <boost/date_time/gregorian/gregorian.hpp>
#include <cstring>
#include <string>
#include <time.h>

namespace HFSAT {

#define SPARE_BSE_FOLDER_PREFIX "/spare/local/tradeinfo/"
#define BSE_ORDER_LIMIT_FILENAME_PREFIX "/spare/local/files/BSEFTPFiles/"
#define BSE_DATASOURCE_FILE_BACKUP_PATH "/spare/local/tradeinfo/BSE_Files/DataExchFile/"
const boost::gregorian::date_duration one_day_duration_(1);
#define BSE_CONTRACT_MASTER_FILE_PREFIX "BSE_Files/BSEContractMaster/BFX_CO"

// filepaths are relative to /spare/local/tradeinfo/
#define BSE_CONTRACT_FILENAME_PREFIX "BSE_Files/ContractFiles/nse_contracts"
#define BSE_DATASOURCE_EXCHSYMBOL_FILE "BSE_Files/datasource_exchsymbol.txt"

#define BSE_INTEREST_RATE_FILE "BSE_Files/interest_rates.txt"
#define BSE_FO_BHAVCOPY_FILENAME_PREFIX "BSE_Files/BhavCopy/fo"
#define BSE_CM_BHAVCOPY_FILENAME_PREFIX "BSE_Files/Margin_Files/Exposure_Files/EQ"
#define BSE_CD_BHAVCOPY_FILENAME_PREFIX "BSE_Files/BhavCopy/cds"

#define BSE_BANNED_SECURITIES_PREFIX "BSE_Files/SecuritiesUnderBan/fo_secban_"

BSESecurityDefinitions* BSESecurityDefinitions::uniqueinstance_ = nullptr;

BSESecurityDefinitions::BSESecurityDefinitions(int date) : intdate_(date), max_exch_sym_id_(0) {
  CurrencyConvertor::SetUniqueInstance(date);
  // If the date for which the BSE files are fetched is a holiday,
  // then we look back at the last working day

  while (HolidayManagerNoThrow::IsExchangeHoliday(EXCHANGE_KEYS::kExchSourceBSEStr, t_intdate_, true)) {
    t_intdate_ = HFSAT::DateTime::CalcPrevDay(t_intdate_);
  }

  LoadCorporateActions(intdate_);
  PopulateExpiryMap();
  PopulateCurrencyExpiryMap();
  PopulateWeeklyOptionsExpiryMap();
  LoadBhavCopyParams(intdate_);
  LoadCDBhavCopyParams(intdate_);
  LoadCMBhavCopyParams(intdate_);
  LoadInstrumentParams();
  ReadWriteDataSourceSymbolToExchSymbolMap();
  banned_prod_list_ = LoadBannedSecurities(intdate_);
}

void BSESecurityDefinitions::LoadCorporateActions(const int t_date_) {
  std::ostringstream bse_corporate_actions_file_oss_;
  std::string bse_corporate_actions_file_name_ = "";
  int curr_expiry_date = ComputeExpiryDate(0);
  bse_corporate_actions_file_oss_ << "/spare/local/tradeinfo/BSE_Files/corporate_actions.csv";

  bse_corporate_actions_file_name_ = bse_corporate_actions_file_oss_.str();

  if (FileUtils::ExistsAndReadable(bse_corporate_actions_file_name_)) {
    std::ifstream bse_corporate_actions_file_;
    bse_corporate_actions_file_.open(bse_corporate_actions_file_name_.c_str(), std::ifstream::in);
    char readline_buffer_[1024];
    if (bse_corporate_actions_file_.is_open()) {
      while (bse_corporate_actions_file_.good()) {
        memset(readline_buffer_, 0, sizeof(readline_buffer_));
        bse_corporate_actions_file_.getline(readline_buffer_, sizeof(readline_buffer_));

        std::vector<char*> tokens_;
        char readline_buffer_copy_[1024];
        std::string trimmed_str_;
        memset(readline_buffer_copy_, 0, sizeof(readline_buffer_copy_));
        strcpy(readline_buffer_copy_, readline_buffer_);

        HFSAT::PerishableStringTokenizer::NonConstStringTokenizer(readline_buffer_copy_, ",", tokens_);
        if (tokens_.size() >= 5 && tokens_[0][0] != '#') {
          int corporate_action_date = std::atoi(tokens_[0]);
          int corp_action_expiry_date = ComputeNextExpiry(corporate_action_date);
          if (curr_expiry_date == corp_action_expiry_date && t_date_ >= corporate_action_date) {
            std::string corporate_action_type_;
            char operation_type_ = tokens_[3][0];
            double corporate_action_value_ = std::stof(tokens_[4]);
            HFSAT::PerishableStringTokenizer::TrimString(tokens_[1], trimmed_str_, ' ');
            HFSAT::PerishableStringTokenizer::TrimString(tokens_[2], corporate_action_type_, ' ');

            underlying_2_corporate_action_value_[trimmed_str_] =
                std::make_tuple(corporate_action_date, operation_type_, corporate_action_value_);
          }
        }
      }
    }
    bse_corporate_actions_file_.close();
  } else {
    std::cerr << "BSE Corporate_Action file " << bse_corporate_actions_file_name_ << " not present\n";
  }
}

void BSESecurityDefinitions::LoadBhavCopyParams(const int t_date_) {
  std::ostringstream bse_bhav_copy_file_name_oss_;
  std::string bse_bhav_copy_file_name_ = "";

  int this_date = t_date_;

  // bhavcopy files for the date D are generated by the same date_stamp unlike bse_contract files
  // get the previous business day and load the data
  this_date = HFSAT::HolidayManagerUtils::GetPrevBusinessDayForExchange("BSE", this_date); // need to update for bse
  // split into dd mm yy
  std::ostringstream date_string_oss_;
  date_string_oss_ << this_date;
  std::string prev_date_ = date_string_oss_.str();
  bse_bhav_copy_file_name_oss_ << BSE_FO_BHAVCOPY_FILENAME_PREFIX << "/" << prev_date_.substr(4, 2)
                               << prev_date_.substr(2, 2) << "/" << prev_date_.substr(6, 2) << prev_date_.substr(4, 2)
                               << "fo_0000.md";
  bse_bhav_copy_file_name_ = SPARE_BSE_FOLDER_PREFIX + bse_bhav_copy_file_name_oss_.str();

  if (FileUtils::ExistsAndReadable(bse_bhav_copy_file_name_)) {
    std::ifstream bse_bhavcopy_file_;
    bse_bhavcopy_file_.open(bse_bhav_copy_file_name_.c_str(), std::ifstream::in);
    char readline_buffer_[1024];
    if (bse_bhavcopy_file_.is_open()) {
      while (bse_bhavcopy_file_.good()) {
        memset(readline_buffer_, 0, sizeof(readline_buffer_));
        bse_bhavcopy_file_.getline(readline_buffer_, sizeof(readline_buffer_));

        std::vector<char*> tokens_;
        // create a copy of line read before using non-const tokenizer
        char readline_buffer_copy_[1024];
        memset(readline_buffer_copy_, 0, sizeof(readline_buffer_copy_));
        strcpy(readline_buffer_copy_, readline_buffer_);

        HFSAT::PerishableStringTokenizer::NonConstStringTokenizer(readline_buffer_copy_, ",", tokens_);
        std::string expr_date_;
        std::string trimmed_str_;
        // trim the inst_type field: contains spaces
        if (tokens_.size() >= 15) HFSAT::PerishableStringTokenizer::TrimString(tokens_[1], trimmed_str_, ' ');
        if (tokens_.size() >= 15 && tokens_[0][0] != '#' &&
            ((trimmed_str_ == "FUTCUR") || (trimmed_str_ == "FUTIRD") || (trimmed_str_ == "OPTCUR"))) {
          NSEInstrumentType_t inst_type_ = StringToInst(trimmed_str_.c_str());
          HFSAT::PerishableStringTokenizer::TrimString(tokens_[2], trimmed_str_, ' ');
          std::string underlying_ = trimmed_str_;

          expr_date_ = GetDateInYYYYMMDD(tokens_[3]);
          // if invalid date, don't add this entry
          if (expr_date_ == "") continue;
          int expiry_ = std::atoi(expr_date_.c_str());
          double strike_price_ = atof(tokens_[4]);
          HFSAT::PerishableStringTokenizer::TrimString(tokens_[5], trimmed_str_, ' ');
          std::string call_or_put_ = trimmed_str_.c_str();
          double last_close_px_ = atof(tokens_[10]);
          int _open_int_ = atoi(tokens_[13]);

          AddDataSourceSymbolFromBhavCopy(inst_type_, underlying_, expiry_, strike_price_, call_or_put_, last_close_px_,
                                          _open_int_);

          if (underlying_2_corporate_action_value_.find(underlying_) != underlying_2_corporate_action_value_.end()) {
            strike_price_ = GetAdjustedValue(underlying_, atof(tokens_[4]));
            AddDataSourceSymbolFromBhavCopy(inst_type_, underlying_, expiry_, strike_price_, call_or_put_,
                                            last_close_px_, _open_int_);
          }
        }
      }  // end while
    }
    bse_bhavcopy_file_.close();
  } else {
    std::cerr << "Fatal error - could not read NSE Bhavcopy file " << bse_bhav_copy_file_name_ << ".Exiting.\n";
    exit(0);
  }
}

void BSESecurityDefinitions::AddDataSourceSymbolFromBhavCopy(BSEInstrumentType_t inst_type_, std::string underlying_,
                                                             int exp_date_, double strike_px_, std::string call_or_put_,
                                                             double last_close_px_, int _open_int_) {
  BSEOPtionsIdentifier_t* t_config_ = new BSEOPtionsIdentifier_t();
  t_config_->inst_type_ = inst_type_;
  t_config_->underlying_ = underlying_;
  t_config_->expiry_ = exp_date_;
  t_config_->strike_price_ = strike_px_;
  t_config_->call_or_put_ = call_or_put_;
  options_param_2_last_close_[*t_config_] = last_close_px_;

  // Also add to map which contains all options which have non-zero OI
  std::ostringstream datasource_sym_;

  std::ostringstream temp_strike_;
  temp_strike_ << std::fixed << std::setprecision(2) << t_config_->strike_price_;

  datasource_sym_ << "BSE_" << t_config_->underlying_ << "_" << t_config_->call_or_put_ << "_" << temp_strike_.str()
                  << "_" << t_config_->expiry_;

  datasource_2_openInterest_[datasource_sym_.str()] = _open_int_;
  if (_open_int_ != 0) {
    non_zero_OI_.push_back(datasource_sym_.str());
  }
}

void BSESecurityDefinitions::LoadCDBhavCopyParams(const int t_date_) {
  std::ostringstream bse_bhav_copy_file_name_oss_;
  std::string bse_bhav_copy_file_name_ = "";

  int this_date = t_date_;

  // bhavcopy files for the date D are generated by the same date_stamp unlike bse_contract files
  // get the previous business day and load the data
  this_date = HFSAT::HolidayManagerUtils::GetPrevBusinessDayForExchange("BSE", this_date);

  // CD specific holidays
  while (this_date == 20150219 || this_date == 20151224 || this_date == 20170221) {
    this_date = HFSAT::HolidayManagerUtils::GetPrevBusinessDayForExchange("NSE", this_date);
  }
  // split into dd mm yy
  std::ostringstream date_string_oss_;
  date_string_oss_ << this_date;
  std::string prev_date_ = date_string_oss_.str();
  bse_bhav_copy_file_name_oss_ << BSE_CD_BHAVCOPY_FILENAME_PREFIX << "/" << prev_date_.substr(4, 2)
                               << prev_date_.substr(2, 2) << "/" << prev_date_.substr(6, 2) << prev_date_.substr(4, 2)
                               << "cd_0000.md";
  bse_bhav_copy_file_name_ = std::string("/spare/local/tradeinfo/") + bse_bhav_copy_file_name_oss_.str();

  if (FileUtils::ExistsAndReadable(bse_bhav_copy_file_name_)) {
    std::ifstream bse_bhavcopy_file_;
    bse_bhavcopy_file_.open(bse_bhav_copy_file_name_.c_str(), std::ifstream::in);
    char readline_buffer_[1024];
    if (bse_bhavcopy_file_.is_open()) {
      while (bse_bhavcopy_file_.good()) {
        memset(readline_buffer_, 0, sizeof(readline_buffer_));
        bse_bhavcopy_file_.getline(readline_buffer_, sizeof(readline_buffer_));

        std::vector<char*> tokens_;
        // create a copy of line read before using non-const tokenizer
        char readline_buffer_copy_[1024];
        memset(readline_buffer_copy_, 0, sizeof(readline_buffer_copy_));
        strcpy(readline_buffer_copy_, readline_buffer_);

        HFSAT::PerishableStringTokenizer::NonConstStringTokenizer(readline_buffer_copy_, ",", tokens_);
        std::string expr_date_;
        std::string trimmed_str_;
        // trim the inst_type field: contains spaces
        if (tokens_.size() >= 15) HFSAT::PerishableStringTokenizer::TrimString(tokens_[1], trimmed_str_, ' ');
        if (tokens_.size() >= 15 && tokens_[0][0] != '#' &&
            ((trimmed_str_ == "FUTCUR") || (trimmed_str_ == "OPTCUR") || (trimmed_str_ == "FUTIRD")|| 
             (trimmed_str_ == "OPTIRD") || (trimmed_str_ == "FUTIRT"))) {
          BSEInstrumentType_t inst_type_ = StringToInst(trimmed_str_.c_str());
          HFSAT::PerishableStringTokenizer::TrimString(tokens_[2], trimmed_str_, ' ');
          std::string underlying_ = trimmed_str_;

          expr_date_ = GetDateInYYYYMMDD(tokens_[3]);
          // if invalid date, don't add this entry
          if (expr_date_ == "") continue;

          int expiry_ = std::atoi(expr_date_.c_str());
          double strike_price_ = atof(tokens_[4]);
          HFSAT::PerishableStringTokenizer::TrimString(tokens_[5], trimmed_str_, ' ');
          std::string call_or_put_ = trimmed_str_.c_str();
          double last_close_px_ = atof(tokens_[10]);

          AddDataSourceSymbolFromBhavCopy(inst_type_, underlying_, expiry_, strike_price_, call_or_put_, last_close_px_,
                                          0);

          if (underlying_2_corporate_action_value_.find(underlying_) != underlying_2_corporate_action_value_.end()) {
            strike_price_ = GetAdjustedValue(underlying_, atof(tokens_[4]));
            AddDataSourceSymbolFromBhavCopy(inst_type_, underlying_, expiry_, strike_price_, call_or_put_,
                                            last_close_px_, 0);
          }
        }
      }  // end while
    }
    bse_bhavcopy_file_.close();
  } else {
    std::cerr << "Fatal error - could not read NSE Bhavcopy file " << bse_bhav_copy_file_name_ << ".Exiting.\n";
    exit(0);
  }
}

void BSESecurityDefinitions::LoadShortCode_Token(const int t_date_){
  std::ostringstream bse_scrip_copy_file_name_oss_;
  std::string bse_scrip_copy_file_name_ = "";
  int this_date = t_date_;

  // get the previous business day and load the data
  this_date = HFSAT::HolidayManagerUtils::GetPrevBusinessDayForExchange("BSE", this_date);
  // split into dd mm yy
  std::ostringstream date_string_oss_;
  date_string_oss_ << this_date;
  std::string prev_date_ = date_string_oss_.str();
  bse_scrip_copy_file_name_oss_ << "/spare/local/files/BSEFTPFiles/" << prev_date_.substr(0, 4) << "/" 
                               << std::stoi(prev_date_.substr(4, 2)) << "/" << prev_date_.substr(6, 2) 
                               << "/SCRIP/SCRIP_"<< prev_date_.substr(6, 2) << std::stoi(prev_date_.substr(4, 2)) 
                               << prev_date_.substr(2, 2) << ".TXT";

  bse_scrip_copy_file_name_ = bse_scrip_copy_file_name_oss_.str();
  if (FileUtils::ExistsAndReadable(bse_scrip_copy_file_name_)) {
  std::ifstream bse_scrip_file_;
    bse_scrip_file_.open(bse_scrip_copy_file_name_.c_str(), std::ifstream::in);
    char readline_buffer_[1024];
    if (bse_scrip_file_.is_open()) {
      while (bse_scrip_file_.good()) {
        memset(readline_buffer_, 0, sizeof(readline_buffer_));
        bse_scrip_file_.getline(readline_buffer_, sizeof(readline_buffer_));

        std::vector<char*> tokens_;
        // create a copy of line read before using non-const tokenizer
        char readline_buffer_copy_[1024];
        memset(readline_buffer_copy_, 0, sizeof(readline_buffer_copy_));
        strcpy(readline_buffer_copy_, readline_buffer_);

        HFSAT::PerishableStringTokenizer::NonConstStringTokenizer(readline_buffer_copy_, ",", tokens_);
        std::string trimmed_str_;
        // trim the inst_type field: contains spaces
        if (tokens_.size() >= 23) HFSAT::PerishableStringTokenizer::TrimString(tokens_[22], trimmed_str_, ' ');
        if (tokens_.size() >= 23 && tokens_[0][0] != '#' && (trimmed_str_ == "EQ")) {
          HFSAT::PerishableStringTokenizer::TrimString(tokens_[2], trimmed_str_, ' ');
          std::string token_ = tokens_[0];
          std::string shortcode_ = "BSE_" + trimmed_str_;
          token_2_shortcode[token_] = shortcode_;
          shortcode_2_token[shortcode] = token_;
          shortcode_2_tick[shortcode] = tokens_[10];
        }
      }  // end while
    }
    bse_scrip_file_.close();
  } else {
    std::cerr << "Fatal error - could not read BSE SCRIP file " << nse_scrip_copy_file_name_ << ".Exiting.\n";
    exit(0);
  }

}

void BSESecurityDefinitions::LoadCMBhavCopyParams(const int t_date_) {
  LoadShortCode_Token(t_date);
  std::ostringstream bse_bhav_copy_file_name_oss_;
  std::string bse_bhav_copy_file_name_ = "";
  int this_date = t_date_;

  // bhavcopy files for the date D are generated by the same date_stamp unlike Bse_contract files
  // get the previous business day and load the data
  this_date = HFSAT::HolidayManagerUtils::GetPrevBusinessDayForExchange("BSE", this_date);
  // split into dd mm yy
  std::ostringstream date_string_oss_;
  date_string_oss_ << this_date;
  std::string prev_date_ = date_string_oss_.str();
  bse_bhav_copy_file_name_oss_ << "BSE_Files/Margin_Files/Exposure_Files/EQ" << prev_date_.substr(6, 2)
                               << std::stoi(prev_date_.substr(4, 2)) << prev_date_.substr(2, 2)
                               << ".CSV";

  bse_bhav_copy_file_name_ = std::string("/spare/local/tradeinfo/") + bse_bhav_copy_file_name_oss_.str();
  if (FileUtils::ExistsAndReadable(bse_bhav_copy_file_name_)) {
    std::ifstream bse_bhavcopy_file_;
    bse_bhavcopy_file_.open(bse_bhav_copy_file_name_.c_str(), std::ifstream::in);
    char readline_buffer_[1024];
    if (bse_bhavcopy_file_.is_open()) {
      while (bse_bhavcopy_file_.good()) {
        memset(readline_buffer_, 0, sizeof(readline_buffer_));
        bse_bhavcopy_file_.getline(readline_buffer_, sizeof(readline_buffer_));

        std::vector<char*> tokens_;
        // create a copy of line read before using non-const tokenizer
        char readline_buffer_copy_[1024];
        memset(readline_buffer_copy_, 0, sizeof(readline_buffer_copy_));
        strcpy(readline_buffer_copy_, readline_buffer_);

        HFSAT::PerishableStringTokenizer::NonConstStringTokenizer(readline_buffer_copy_, ",", tokens_);
        std::string expr_date_;
        std::string trimmed_str_;
        // trim the inst_type field: contains spaces
        if (tokens_.size() >= 9) HFSAT::PerishableStringTokenizer::TrimString(tokens_[3], trimmed_str_, ' ');
        if (tokens_.size() >= 9 && tokens_[0][0] != '#' && (trimmed_str_ == "Q")) {
          HFSAT::PerishableStringTokenizer::TrimString(tokens_[0], trimmed_str_, ' ');
          std::string shortcode_ = token_2_shortcode[trimmed_str_];
          shortcode_2_type_[shortcode_] = HFSAT::NSE_EQ;
          shortcode_2_last_close_[shortcode_] = std::stof(tokens_[5]);
          // std::cout << "sc, close:: " << shortcode_ << ", " <<  shortcode_2_last_close_[trimmed_str_] << "\n";
        }
      }  // end while
    }
    nse_bhavcopy_file_.close();
  } else {
    std::cerr << "Fatal error - could not read NSE Bhavcopy file " << nse_bhav_copy_file_name_ << ".Exiting.\n";
    exit(0);
  }
  
}

void BSESecurityDefinitions::LoadInstrumentParams() {
  std::string contract_master_file_absolute_path_(
      "/spare/local/tradeinfo/BSE_Files/BSEContractMaster/bse_contract_master_futures");
  if (FileUtils::ExistsAndReadable(contract_master_file_absolute_path_)) {
    std::ifstream infile(contract_master_file_absolute_path_, std::ifstream::in);
    std::vector<std::string> params;

    if (infile.is_open()) {
      std::string line;
      while (infile.good()) {
        getline(infile, line);
        if (line.empty()) {
          break;
        }

        std::istringstream ss(line);
        params.clear();

        std::string field;
        while (getline(ss, field, ',')) {
          params.push_back(field);
        }

        if (params.size() >= 19) {
          BSEInstrumentParams inst_param;
          inst_param.instrument_code = std::atoi(params[0].c_str());
          inst_param.instrument_type = BSEInstrumentType::BSE_INVALID;
          if (params[6] == "FUTCUR") {
            inst_param.instrument_type = BSEInstrumentType::BSE_CURFUT;
          } else if (params[6] == "OPTCUR") {
            inst_param.instrument_type = BSEInstrumentType::BSE_CUROPT;
          } else if (params[6] == "FUTIRD") {
            inst_param.instrument_type = BSEInstrumentType::BSE_IRDFUT;
          } else if (params[6] == "FUTIRT") {
            inst_param.instrument_type = BSEInstrumentType::BSE_IRTFUT;
          }
          std::strcpy(inst_param.underlying, params[2].c_str());

          int day = std::atoi(params[18].substr(8, 2).c_str());
          int year = std::atoi(params[18].substr(0, 4).c_str());
          std::string month = params[18].substr(5, 2);
          int mon = std::atoi(month.c_str());
          /*if (month == "JAN") {
            mon = 1;
          } else if (month == "FEB") {
            mon = 2;
          } else if (month == "MAR") {
            mon = 3;
          } else if (month == "APR") {
            mon = 4;
          } else if (month == "MAY") {
            mon = 5;
          } else if (month == "JUN") {
            mon = 6;
          } else if (month == "JUL") {
            mon = 7;
          } else if (month == "AUG") {
            mon = 8;
          } else if (month == "SEP") {
            mon = 9;
          } else if (month == "OCT") {
            mon = 10;
          } else if (month == "NOV") {
            mon = 11;
          } else if (month == "DEC") {
            mon = 12;
          }*/
          inst_param.expiry = year * 10000 + mon * 100 + day;
          inst_param.strike_price = std::atoi(params[10].c_str()) / double(10000000);
          inst_param.option_type = BSEOptionType::OPT_INVALID;
          if (params[7] == "CE") {
            inst_param.option_type = BSEOptionType::OPT_CE;
          } else if (params[7] == "PE") {
            inst_param.option_type = BSEOptionType::OPT_PE;
          }
          inst_param.precision = std::atoi(params[9].c_str());
          inst_param.min_lot_size = std::atoi(params[11].c_str());
          inst_param.min_px_inc = std::atoi(params[13].c_str()) / double(10000000);
          inst_param.lot_size_multiplier = std::atoi(params[14].c_str());

          std::strcpy(inst_param.name, params[3].c_str());
          inst_param.last_close =
              0;  // [pjain] : In New Master Files, its value is is column 16. But it varies across master
                  // files for the same instrument. So for the time being I have removed column 16
                  // from the processed contract master file.

          instrument_code_2_params_[inst_param.instrument_code] = instrument_params_.size();
          instrument_params_.push_back(inst_param);
          /*std::cout << inst_param.ToString();
          std::cout << "Shortcode : " << GetShortcodeFromInstrumentCode(inst_param.instrument_code) << "\n";
          std::cout << "Data Source Symbol : " << GetDataSourceSymbolFromInstrumentCode(inst_param.instrument_code)
                    << "\n";*/
        }
      }
    }
  } else {
    std::cerr << typeid(*this).name() << ':' << __func__ << " "
              << " ERROR : Contract maste file " << contract_master_file_absolute_path_
              << " does not exist or readable.\n";
  }
}

void NSESecurityDefinitions::PopulateWeeklyOptionsExpiryMap() {
  std::set<int> monthly_fo_expiries;

  for (uint32_t t_ctr_ = 0; t_ctr_ < 6; t_ctr_++) {
    monthly_fo_expiries.insert(ComputeExpiryDate(t_ctr_));
  }

  for (uint32_t expiry_num = 0; expiry_num < 15; expiry_num++) {
    weekly_option_contractnumber_2_expirydate_[expiry_num] =
        ComputeExpiryDateWeeklyOptions(expiry_num, monthly_fo_expiries);
    weekly_option_expirydate_2_contractnumber_[weekly_option_contractnumber_2_expirydate_[expiry_num]] = expiry_num;
  }
}

void BSESecurityDefinitions::ReadWriteDataSourceSymbolToExchSymbolMap() {
  std::string mapping_filepath = std::string(SPARE_BSE_FOLDER_PREFIX) + std::string(BSE_DATASOURCE_TO_EXCH_SYM_FILE);
  // std::cout << "Datasource Exchange Symbol File Path : " << mapping_filepath << "\n";

  // 1. Read File and Fill Internal Data Structures "exch_sym_2_datasource_sym_" and "datasource_sym_2_exch_sym_"
  if (FileUtils::ExistsAndReadable(mapping_filepath)) {
    std::ifstream infile(mapping_filepath, std::ifstream::in);
    std::vector<std::string> params;

    if (infile.is_open()) {
      std::string line;
      while (infile.good()) {
        getline(infile, line);
        if (line.empty()) {
          break;
        }

        std::istringstream ss(line);
        params.clear();

        std::string field;
        while (getline(ss, field, ' ')) {
          params.push_back(field);
        }

        if (params.size() >= 2) {
          const std::string& exch_sym = params[0];
          const std::string& data_source_sym = params[1];
          // std::cout << "Exch Symbol : " << exch_sym << " Data Source Sym : " << data_source_sym << "\n";
          exch_sym_2_datasource_sym_[exch_sym] = data_source_sym;
          datasource_sym_2_exch_sym_[data_source_sym] = exch_sym;
          long long int exch_sym_id = 0;
          size_t last_index = exch_sym.find_last_not_of("0123456789");
          std::string id = exch_sym.substr(last_index + 1);
          if (!id.empty()) {
            exch_sym_id = std::atoll(id.c_str());
            if (exch_sym_id > max_exch_sym_id_) {
              max_exch_sym_id_ = exch_sym_id;
            }
          }
        }
      }
    }
    infile.close();
  } else {
    std::cerr << typeid(*this).name() << ':' << __func__ << " "
              << "BSE Datasource Symbol to Exchange Symbol file not exist/readable at location " << mapping_filepath
              << ". Exiting\n";
    exit(1);
  }

  // 2. Parse the fields of contract master file and see if some new datasource symbol is added. If its is added, backup
  // the contents of datasourcesymboltoexchsymbol file before modifying.
  bool is_backup_done = false;
  for (BSEInstrumentParams& param : instrument_params_) {
    if (param.instrument_type == BSEInstrumentType::BSE_CURFUT /*||
          param.instrument_type == BSEInstrumentType::BSE_IRDFUT ||
          param.instrument_type == BSEInstrumentType::BSE_IRTFUT*/) {
      const std::string data_source_sym = GetDataSourceSymbolFromInstrumentCode(param.instrument_code);
      if (!IsDataSourceSymbolValid(data_source_sym)) {
        if (!is_backup_done) {
          time_t time_midnight = HFSAT::DateTime::GetTimeMidnightUTC(intdate_);
          std::string backup_filepath = std::string(BSE_DATASOURCE_FILE_BACKUP_PATH) +
                                        std::string(BSE_DATASOURCE_TO_EXCH_SYM_FILE) + "." +
                                        std::to_string(time_midnight);
          // std::cout << "Backup File Path : " << backup_filepath << "\n";
          if (!BSE_UTILS::BackupFile(mapping_filepath, backup_filepath)) {
            std::cerr << typeid(*this).name() << ':' << __func__ << " "
                      << "Could not backup " << mapping_filepath << " to file " << backup_filepath << " . Exiting.\n";
            exit(1);
          }
          is_backup_done = true;
        }
        std::string new_exch_sym = "BSE_" + std::to_string(++max_exch_sym_id_);
        if (new_exch_sym.size() > 16) {
          std::cerr << typeid(*this).name() << ':' << __func__ << " "
                    << "Exch Symbol Size going beyond 16 chars. Exiting.\n";
          exit(1);
        }
        exch_sym_2_datasource_sym_[new_exch_sym] = data_source_sym;
        datasource_sym_2_exch_sym_[data_source_sym] = new_exch_sym;
        // std::cout << "NEW : Exch Symbol : " << new_exch_sym << " Data Source Sym : " << data_source_sym << "\n";
      }
    }
  }

  // 3. Update the data source to exch symbol mapping file in case of new data source symbols.
  if (is_backup_done) {
    std::ofstream outfile(mapping_filepath, std::ofstream::out);
    if (outfile.is_open()) {
      for (auto iter = exch_sym_2_datasource_sym_.begin(); iter != exch_sym_2_datasource_sym_.end(); iter++) {
        outfile << iter->first << " " << iter->second << "\n";
      }
      outfile.close();
    } else {
      std::cerr << typeid(*this).name() << ':' << __func__ << " "
                << "Could not write new Data Source Symbol : Exch Symbol mapping.";
    }
  }
}

void BSESecurityDefinitions::AddContractSpecifications(ShortcodeContractSpecificationMap& contract_spec_map) {
  for (BSEInstrumentParams& param : instrument_params_) {
    if (param.instrument_type == BSEInstrumentType::BSE_CURFUT /*||
        param.instrument_type == BSEInstrumentType::BSE_IRDFUT ||
        param.instrument_type == BSEInstrumentType::BSE_IRTFUT*/) {
      if (IsExpiryValid(param.expiry, param.instrument_type)) {
        const std::string& shortcode = GetShortcodeFromInstrumentCode(param.instrument_code);
        contract_spec_map[shortcode] = ContractSpecification(
            param.min_px_inc, param.lot_size_multiplier * CurrencyConvertor::Convert(kCurrencyINR, kCurrencyUSD),
            kExchSourceBSE, param.min_lot_size);
        shortcode_2_instrument_code[shortcode] = param.instrument_code;
        /*std::cout << "Contract Spec Map:\nShortcode : " << GetShortcodeFromInstrumentCode(param.instrument_code) <<
           "\n"
                  << "Min Px Inc : " << param.min_px_inc << "\n"
                  << "n2d : " << param.lot_size * CurrencyConvertor::Convert(kCurrencyINR, kCurrencyUSD) << "\n"
                  << "Lot Size : " << param.lot_size << "\n";*/
      }
    }
  }
}

void BSESecurityDefinitions::PopulateCurrencyExpiryMap() {
  // Support for only 3 out of 12 listed currently
  // std::cout << "Expiries for Currency : \n";
  for (uint32_t contract_num = 0; contract_num < 3; contract_num++) {
    contractnumber_cf_2_expirydate_[contract_num] = ComputeExpiryDate(contract_num, true);
    /*std::cout << "Contract Num : " << contract_num << "\n"
              << "Expiry : " << contractnumber_cf_2_expirydate_[contract_num] << "\n";*/
    expirydate_2_contractnumber_cf_[contractnumber_cf_2_expirydate_[contract_num]] = contract_num;
  }
}

void BSESecurityDefinitions::PopulateExpiryMap() {
  // 3 contracts outstanding in BSE
  // std::cout << "Expiries for !Currency : \n";
  for (uint32_t contract_num = 0; contract_num < 3; contract_num++) {
    contractnumber_2_expirydate_[contract_num] = ComputeExpiryDate(contract_num);
    /*std::cout << "Contract Num : " << contract_num << "\n"
              << "Expiry : " << contractnumber_2_expirydate_[contract_num] << "\n";*/
    expirydate_2_contractnumber_[contractnumber_2_expirydate_[contract_num]] = contract_num;
  }
}

int BSESecurityDefinitions::ComputeExpiryDate(const int contract_number, bool is_currency) {
  int contract_num = contract_number;
  int temp_date = intdate_;
  int expiry_date = 0;
  while (contract_num >= 0) {
    if (!is_currency) {
      expiry_date = ComputeNextExpiry(temp_date);
    } else {
      expiry_date = ComputeNextExpiryCurrency(temp_date);
    }
    contract_num--;
    if (contract_num >= 0)  // set date to 1st of next month
    {
      int month = (expiry_date % 10000) / 100;
      int year = expiry_date / 10000;
      if (month == 12) {
        temp_date = (year + 1) * 10000 + 101;
      } else {
        temp_date = year * 10000 + (month + 1) * 100 + 1;
      }
    }  // end if
  }    // end while
  return expiry_date;
}

int BSESecurityDefinitions::ComputeNextExpiryCurrency(const int date) {
  int month = (date % 10000) / 100;
  int year = date / 10000;

  boost::gregorian::date first_of_month(year, month, 1);
  boost::gregorian::date current_date = first_of_month.end_of_month();
  boost::gregorian::date::ymd_type ymd = current_date.year_month_day();

  int expiry_date = ((ymd.year * 100 + ymd.month) * 100) + ymd.day;

  /// we need to find three working days
  for (int i = 0; i < 3; i++) {
    while (HolidayManagerNoThrow::IsExchangeHoliday(EXCHANGE_KEYS::kExchSourceBSEStr, expiry_date, true)) {
      current_date -= one_day_duration_;
      ymd = current_date.year_month_day();
      expiry_date = ((ymd.year * 100 + ymd.month) * 100) + ymd.day;
    }
    if (i < 2) {
      current_date -= one_day_duration_;
      ymd = current_date.year_month_day();
      expiry_date = ((ymd.year * 100 + ymd.month) * 100) + ymd.day;
    }
  }

  if (expiry_date >= date) {
    return expiry_date;
  } else  // set date to first of next month
  {
    int temp_date;
    if (month == 12) {
      temp_date = (year + 1) * 10000 + 101;
    } else {
      temp_date = year * 10000 + (month + 1) * 100 + 1;
    }
    return ComputeNextExpiryCurrency(temp_date);
  }
}

int BSESecurityDefinitions::ComputeNextExpiry(const int date) {
  int month = (date % 10000) / 100;
  int year = date / 10000;

  boost::gregorian::last_day_of_the_week_in_month lwdm(boost::gregorian::Thursday, month);
  boost::gregorian::date l_thursday = lwdm.get_date(year);
  boost::gregorian::date::ymd_type ymd = l_thursday.year_month_day();
  int expiry_date = ((ymd.year * 100 + ymd.month) * 100) + ymd.day;
  while (HolidayManagerNoThrow::IsExchangeHoliday(EXCHANGE_KEYS::kExchSourceBSEStr, expiry_date, true)) {
    l_thursday -= one_day_duration_;
    boost::gregorian::date::ymd_type ymd = l_thursday.year_month_day();
    expiry_date = ((ymd.year * 100 + ymd.month) * 100) + ymd.day;
  }

  if (expiry_date >= date) {
    return expiry_date;
  } else  // set date to first of next month
  {
    int temp_date;
    if (month == 12) {
      temp_date = (year + 1) * 10000 + 101;
    } else {
      temp_date = year * 10000 + (month + 1) * 100 + 1;
    }
    return ComputeNextExpiry(temp_date);
  }
}

int BSESecurityDefinitions::GetContractNumberFromExpiry(const int date, const BSEInstrumentType type) {
  if (type == HFSAT::BSEInstrumentType::BSE_CURFUT || type == HFSAT::BSEInstrumentType::BSE_CUROPT) {
    if (expirydate_2_contractnumber_cf_.find(date) != expirydate_2_contractnumber_cf_.end()) {
      return expirydate_2_contractnumber_cf_[date];
    }
  } else {
    if (expirydate_2_contractnumber_.find(date) != expirydate_2_contractnumber_.end()) {
      return expirydate_2_contractnumber_[date];
    }
  }

  std::cerr << typeid(*this).name() << ':' << __func__ << " "
            << "Fatal error - GetContractNumberFromExpiry called with invalid parameters " << date << " ";
  exit(0);
}

bool BSESecurityDefinitions::IsExpiryValid(const int expiry, const BSEInstrumentType type) {
  if (type == HFSAT::BSEInstrumentType::BSE_CURFUT || type == HFSAT::BSEInstrumentType::BSE_CUROPT) {
    return (expirydate_2_contractnumber_cf_.find(expiry) != expirydate_2_contractnumber_cf_.end());
  } else {
    return (expirydate_2_contractnumber_.find(expiry) != expirydate_2_contractnumber_.end());
  }
}

bool BSESecurityDefinitions::IsExpiryValidForInstrument(int instrument_code) {
  if (IsInstrumentValid(instrument_code)) {
    return IsExpiryValid(instrument_params_[instrument_code_2_params_[instrument_code]].expiry,
                         instrument_params_[instrument_code_2_params_[instrument_code]].instrument_type);
  }
  std::cerr << typeid(*this).name() << ':' << __func__ << " "
            << "Instrument " << instrument_code << "Invalid\n";
  return false;
}

const std::string BSESecurityDefinitions::GetShortcodeFromInstrumentCode(const int instrument_code) {
  if (instrument_code_2_params_.find(instrument_code) == instrument_code_2_params_.end() ||
      instrument_params_.size() < (instrument_code_2_params_[instrument_code] + 1)) {
    return "";
  }
  BSEInstrumentParams param = instrument_params_[instrument_code_2_params_[instrument_code]];
  std::ostringstream shortcode(std::string(""));
  // FIXME: Only Implemented for futures
  if (IsExpiryValid(param.expiry, param.instrument_type)) {
    if (param.instrument_type == BSEInstrumentType::BSE_CURFUT /*||
	          param.instrument_type == BSEInstrumentType::BSE_IRDFUT ||
	          param.instrument_type == BSEInstrumentType::BSE_IRTFUT*/) {
      shortcode << "BSE_" << param.underlying << "_FUT"
                << GetContractNumberFromExpiry(param.expiry, param.instrument_type);
    }
  }

  return shortcode.str();
}

const std::string BSESecurityDefinitions::GetDataSourceSymbolFromInstrumentCode(const int instrument_code) {
  if (instrument_code_2_params_.find(instrument_code) == instrument_code_2_params_.end() ||
      instrument_params_.size() < (instrument_code_2_params_[instrument_code] + 1)) {
    std::cerr << typeid(*this).name() << ':' << __func__ << " "
              << "Instrument Code " << instrument_code << " invalid. Exiting.";
    exit(1);
  }
  BSEInstrumentParams param = instrument_params_[instrument_code_2_params_[instrument_code]];
  std::ostringstream data_source_symbol;

  // FIXME: Only Implemented for futures
  if (param.instrument_type == BSEInstrumentType::BSE_CURFUT /*||
	        param.instrument_type == BSEInstrumentType::BSE_IRDFUT ||
	        param.instrument_type == BSEInstrumentType::BSE_IRTFUT*/) {
    data_source_symbol << "BSE_" << param.underlying << "_FUT_" << param.expiry;
  }

  return data_source_symbol.str();
}

short int BSESecurityDefinitions::GetPrecisionFromInstrumentCode(const int instrument_code) {
  int precision = 0;
  if (IsInstrumentValid(instrument_code)) {
    precision = instrument_params_[instrument_code_2_params_[instrument_code]].precision;
  }
  return precision;
}

const std::string BSESecurityDefinitions::GetDataSourceSymbolFromShortcode(const std::string& shortcode) {
  int instrument_code = GetInstrumentCodeFromShortcode(shortcode);
  if (IsInstrumentValid(instrument_code)) {
    return (GetDataSourceSymbolFromInstrumentCode(instrument_code));
  } else {
    std::cerr << typeid(*this).name() << ':' << __func__ << " "
              << "Instrument with Code " << instrument_code << "not present\n ";
    exit(1);
  }
}

const std::string BSESecurityDefinitions::GetDataSourceSymbolFromExchSymbol(const std::string& exch_symbol) {
  if (IsExchSymbolValid(exch_symbol)) {
    return exch_sym_2_datasource_sym_[exch_symbol];
  } else {
    std::cerr << typeid(*this).name() << ':' << __func__ << " "
              << "Exchange Symbol " << exch_symbol << " invalid. Exiting.\n";
    exit(1);
  }
}

const std::string BSESecurityDefinitions::GetExchSymbolFromShortcode(const std::string& shortcode) {
  const std::string& data_source_symbol = GetDataSourceSymbolFromShortcode(shortcode);
  if (IsDataSourceSymbolValid(data_source_symbol)) {
    return datasource_sym_2_exch_sym_[data_source_symbol];
  } else {
    std::cerr << typeid(*this).name() << ':' << __func__ << " "
              << "Data Source Symbol " << data_source_symbol << " not present. Exiting.\n";
    exit(1);
  }
}

const std::string BSESecurityDefinitions::GetExchangeSymbolFromInstumentCode(int instrument_code) {
  const std::string& shortcode = GetShortcodeFromInstrumentCode(instrument_code);
  return GetExchSymbolFromShortcode(shortcode);
}

inline int BSESecurityDefinitions::GetInstrumentCodeFromShortcode(const std::string& shortcode) {
  if (IsShortcodeValid(shortcode)) {
    return shortcode_2_instrument_code[shortcode];
  } else {
    std::cerr << typeid(*this).name() << ':' << __func__ << " "
              << "Invalid Shortcode " << shortcode << ". Exiting.\n";
    exit(1);
  }
}

double BSESecurityDefinitions::GetLastClose(const std::string& shortcode) {
  if (IsShortcodeValid(shortcode)) {
    return GetLastCloseFromInstrumentCode(shortcode_2_instrument_code[shortcode]);
  } else {
    std::cerr << typeid(*this).name() << ':' << __func__ << " "
              << "Invalid Shortcode " << shortcode << ". Exiting.\n";
    exit(1);
  }
}

double BSESecurityDefinitions::GetLastCloseFromInstrumentCode(const int instrument_code) {
  if (IsInstrumentValid(instrument_code)) {
    return instrument_params_[instrument_code_2_params_[instrument_code]].last_close;
  } else {
    std::cerr << typeid(*this).name() << ':' << __func__ << " "
              << "Instrument with Code " << instrument_code << "not present\n ";
    exit(1);
  }
}

double BSESecurityDefinitions::GetContractMultiplier(const std::string& shortcode) {
  if (IsShortcodeValid(shortcode)) {
    return GetContractMultiplierFromInstrumentCode(shortcode_2_instrument_code[shortcode]);
  } else {
    std::cerr << typeid(*this).name() << ':' << __func__ << " "
              << "Invalid Shortcode " << shortcode << ". Exiting.\n";
    exit(1);
  }
}

double BSESecurityDefinitions::GetContractMultiplierFromInstrumentCode(const int instrument_code) {
  if (IsInstrumentValid(instrument_code)) {
    return instrument_params_[instrument_code_2_params_[instrument_code]].lot_size_multiplier;
  } else {
    std::cerr << typeid(*this).name() << ':' << __func__ << " "
              << "Instrument with Code " << instrument_code << "not present\n ";
    exit(1);
  }
}

BSEInstrumentType BSESecurityDefinitions::GetInstrumentTypeFromShortcode(const std::string& shortcode) {
  int instrument_code = GetInstrumentCodeFromShortcode(shortcode);
  if (IsInstrumentValid(instrument_code)) {
    return instrument_params_[instrument_code_2_params_[instrument_code]].instrument_type;
  } else {
    std::cerr << typeid(*this).name() << ':' << __func__ << " "
              << "Instrument with Code " << instrument_code << "not present\n ";
    exit(1);
  }
}

double BSESecurityDefinitions::GetBSECommission(const std::string& shortcode) {
  if (IsShortcodeValid(shortcode)) {
    if (shortcode_2_commissions_.find(shortcode) != shortcode_2_commissions_.end()) {
      return shortcode_2_commissions_[shortcode];
    } else {
      double commission = 0;
      switch (GetInstrumentTypeFromShortcode(shortcode)) {
        case BSE_CURFUT:
          commission = 0;
          shortcode_2_commissions_[shortcode] = commission;
          break;
        case BSE_CUROPT:
          commission = 0;
          shortcode_2_commissions_[shortcode] = commission;
          break;
        case BSE_IRDFUT:
          commission = 0;
          shortcode_2_commissions_[shortcode] = commission;
          break;
        case BSE_IRTFUT:
          commission = 0;
          shortcode_2_commissions_[shortcode] = commission;
          break;
        default:
          std::cerr << typeid(*this).name() << ':' << __func__ << " "
                    << "GetBSECommission called with improper instrument type "
                    << GetInstrumentTypeFromShortcode(shortcode);
          exit(0);
          break;
      }
      return commission;
    }
  } else {
    std::cerr << typeid(*this).name() << ':' << __func__ << " "
              << "Invalid Shortcode " << shortcode << ". Exiting.\n";
    exit(1);
  }
}

std::vector<std::string> BSESecurityDefinitions::LoadBannedSecurities(const int t_date_) {
  std::string banned_securities_file_absolute_path_ =
      std::string("/spare/local/tradeinfo/") + BSE_BANNED_SECURITIES_PREFIX + std::to_string(t_date_) + ".csv";
  std::vector<std::string> banned_securities_list_;
  if (FileUtils::ExistsAndReadable(banned_securities_file_absolute_path_)) {
    std::ifstream banned_securities_file_;
    banned_securities_file_.open(banned_securities_file_absolute_path_.c_str(), std::ifstream::in);
    char readline_buffer_[1024];
    if (banned_securities_file_.is_open()) {
      while (banned_securities_file_.good()) {
        memset(readline_buffer_, 0, sizeof(readline_buffer_));
        banned_securities_file_.getline(readline_buffer_, sizeof(readline_buffer_));
        PerishableStringTokenizer st_(readline_buffer_, sizeof(readline_buffer_));

        const std::vector<const char*>& tokens_ = st_.GetTokens();
        if (tokens_.size() != 1) {
          continue;
        }
        banned_securities_list_.push_back(tokens_[0]);
      }  // end while
    }
    banned_securities_file_.close();
  } else {
    std::cerr << "Banned securities file not present for BSE - " << banned_securities_file_absolute_path_ << '\n';
  }
  return banned_securities_list_;
}

BSEInstrumentType_t BSESecurityDefinitions::StringToInst(const char* str) {
  if ((strcmp(str, "IDXFUT") == 0) || (strcmp(str, "FUTIDX") == 0) || (strcmp(str, "IF") == 0))
    return BSE_IDXFUT;
  else if ((strcmp(str, "STKFUT") == 0) || (strcmp(str, "FUTSTK") == 0) || (strcmp(str, "SF") == 0))
    return BSE_STKFUT;
  else if ((strcmp(str, "IDXOPT") == 0) || (strcmp(str, "OPTIDX") == 0) || (strcmp(str, "IO") == 0) )
    return BSE_IDXOPT;
  else if ((strcmp(str, "STKOPT") == 0) || (strcmp(str, "OPTSTK") == 0) || (strcmp(str, "SO") == 0))
    return BSE_STKOPT;
  else if ((strcmp(str, "CURFUT") == 0) || (strcmp(str, "FUTCUR") == 0))
    return BSE_CURFUT;
  else if ((strcmp(str, "IRDFUT") == 0) || (strcmp(str, "FUTIRD") == 0) )
    return BSE_IRDFUT;
  else if ((strcmp(str, "FUTIRT") == 0) || (strcmp(str, "IRTFUT") == 0) )
    return BSE_IRTFUT;
  else if ((strcmp(str, "OPTIRD") == 0) || () )
    return BSE_OPTIRD;
  else
    return BSE_CUROPT;
}
}
